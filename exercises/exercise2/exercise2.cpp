
#include <chrono>
#include <condition_variable>
#include <iostream>
#include <random>
#include <sstream>
#include <string>
#include <thread>
#include <vector>

namespace {

    bool stop = false;

    struct StorageBox {

        void put(const std::string &value) {

            std::unique_lock<std::mutex> lck(mutex_);
            while (!read_) cv_.wait(lck);

            value_ = value;

            read_ = false;
            cv_.notify_all();
        }

        std::string get() {

            std::unique_lock<std::mutex> lck(mutex_);
            while (read_) cv_.wait(lck);

            auto value = value_;

            read_ = true;
            cv_.notify_all();

            return value;
        }

    private:
        bool read_{false};
        std::string value_;
        std::mutex mutex_;
        std::condition_variable cv_;
    };

    void consumer(StorageBox *storage) {
        while (!stop) {
            auto value = storage->get();
            std::cout << "Consumer read value: " << value;
        }
    }

    void producer(StorageBox *storage, std::default_random_engine *generator, int id) {

        std::uniform_int_distribution<int> distribution(0, 100);

        while (!stop) {

            std::stringstream ss;
            ss << "Random number generated by producer '" << id << "': " << distribution(*generator) << std::endl;

            storage->put(ss.str());

            std::this_thread::sleep_for(std::chrono::milliseconds(distribution(*generator) * 10));
        }
    }
}// namespace


int main() {

    StorageBox storage{};
    std::default_random_engine generator;

    const int numProducers = 3;
    std::vector<std::thread> producerThreads(numProducers);
    for (int i = 1; i <= numProducers; i++) {
        producerThreads.emplace_back(std::thread(&producer, &storage, &generator, i));
    }

    std::thread consumerThread(&consumer, &storage);

    std::cout << "Press any key to exit.." << std::endl;
    std::cin.get();

    stop = true;

    consumerThread.join();

    for (auto &t : producerThreads) {
        if (t.joinable()) t.join();
    }

    return 0;
}